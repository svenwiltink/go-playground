// CODE GENERATED BY "generateFunctions". DO NOT EDIT MANUALLY
package codegeneration

func ContainsByte(slice []byte, n byte) bool {
	for _, item := range slice {
		if item == n {
			return true
		}
	}
	return false
}

func ContainsBool(slice []bool, n bool) bool {
	for _, item := range slice {
		if item == n {
			return true
		}
	}
	return false
}

func ContainsInt(slice []int, n int) bool {
	for _, item := range slice {
		if item == n {
			return true
		}
	}
	return false
}

func ContainsFloat32(slice []float32, n float32) bool {
	for _, item := range slice {
		if item == n {
			return true
		}
	}
	return false
}

func ContainsFloat64(slice []float64, n float64) bool {
	for _, item := range slice {
		if item == n {
			return true
		}
	}
	return false
}

func ContainsString(slice []string, n string) bool {
	for _, item := range slice {
		if item == n {
			return true
		}
	}
	return false
}

func ContainsInt8(slice []int8, n int8) bool {
	for _, item := range slice {
		if item == n {
			return true
		}
	}
	return false
}

func ContainsInt16(slice []int16, n int16) bool {
	for _, item := range slice {
		if item == n {
			return true
		}
	}
	return false
}

func CountByte(slice []byte, n byte) int {
	instances := 0
	for _, item := range slice {
		if item == n {
			instances++
		}
	}
	return instances
}

func CountBool(slice []bool, n bool) int {
	instances := 0
	for _, item := range slice {
		if item == n {
			instances++
		}
	}
	return instances
}

func CountInt(slice []int, n int) int {
	instances := 0
	for _, item := range slice {
		if item == n {
			instances++
		}
	}
	return instances
}

func CountFloat32(slice []float32, n float32) int {
	instances := 0
	for _, item := range slice {
		if item == n {
			instances++
		}
	}
	return instances
}

func CountFloat64(slice []float64, n float64) int {
	instances := 0
	for _, item := range slice {
		if item == n {
			instances++
		}
	}
	return instances
}

func CountString(slice []string, n string) int {
	instances := 0
	for _, item := range slice {
		if item == n {
			instances++
		}
	}
	return instances
}

func CountInt8(slice []int8, n int8) int {
	instances := 0
	for _, item := range slice {
		if item == n {
			instances++
		}
	}
	return instances
}

func CountInt16(slice []int16, n int16) int {
	instances := 0
	for _, item := range slice {
		if item == n {
			instances++
		}
	}
	return instances
}

func DeleteByte(slice []byte, i int) []byte {
	return append(slice[:i], slice[i+1:]...)
}

func DeleteBool(slice []bool, i int) []bool {
	return append(slice[:i], slice[i+1:]...)
}

func DeleteInt(slice []int, i int) []int {
	return append(slice[:i], slice[i+1:]...)
}

func DeleteFloat32(slice []float32, i int) []float32 {
	return append(slice[:i], slice[i+1:]...)
}

func DeleteFloat64(slice []float64, i int) []float64 {
	return append(slice[:i], slice[i+1:]...)
}

func DeleteString(slice []string, i int) []string {
	return append(slice[:i], slice[i+1:]...)
}

func DeleteInt8(slice []int8, i int) []int8 {
	return append(slice[:i], slice[i+1:]...)
}

func DeleteInt16(slice []int16, i int) []int16 {
	return append(slice[:i], slice[i+1:]...)
}

func IndexByte(slice []byte, n byte) int {
	for index, item := range slice {
		if item == n {
			return index
		}
	}
	return -1
}

func IndexBool(slice []bool, n bool) int {
	for index, item := range slice {
		if item == n {
			return index
		}
	}
	return -1
}

func IndexInt(slice []int, n int) int {
	for index, item := range slice {
		if item == n {
			return index
		}
	}
	return -1
}

func IndexFloat32(slice []float32, n float32) int {
	for index, item := range slice {
		if item == n {
			return index
		}
	}
	return -1
}

func IndexFloat64(slice []float64, n float64) int {
	for index, item := range slice {
		if item == n {
			return index
		}
	}
	return -1
}

func IndexString(slice []string, n string) int {
	for index, item := range slice {
		if item == n {
			return index
		}
	}
	return -1
}

func IndexInt8(slice []int8, n int8) int {
	for index, item := range slice {
		if item == n {
			return index
		}
	}
	return -1
}

func IndexInt16(slice []int16, n int16) int {
	for index, item := range slice {
		if item == n {
			return index
		}
	}
	return -1
}

func LastIndexByte(slice []byte, n byte) int {
	lastIndex := -1
	for index, item := range slice {
		if item == n {
			lastIndex = index
		}
	}
	return lastIndex
}

func LastIndexBool(slice []bool, n bool) int {
	lastIndex := -1
	for index, item := range slice {
		if item == n {
			lastIndex = index
		}
	}
	return lastIndex
}

func LastIndexInt(slice []int, n int) int {
	lastIndex := -1
	for index, item := range slice {
		if item == n {
			lastIndex = index
		}
	}
	return lastIndex
}

func LastIndexFloat32(slice []float32, n float32) int {
	lastIndex := -1
	for index, item := range slice {
		if item == n {
			lastIndex = index
		}
	}
	return lastIndex
}

func LastIndexFloat64(slice []float64, n float64) int {
	lastIndex := -1
	for index, item := range slice {
		if item == n {
			lastIndex = index
		}
	}
	return lastIndex
}

func LastIndexString(slice []string, n string) int {
	lastIndex := -1
	for index, item := range slice {
		if item == n {
			lastIndex = index
		}
	}
	return lastIndex
}

func LastIndexInt8(slice []int8, n int8) int {
	lastIndex := -1
	for index, item := range slice {
		if item == n {
			lastIndex = index
		}
	}
	return lastIndex
}

func LastIndexInt16(slice []int16, n int16) int {
	lastIndex := -1
	for index, item := range slice {
		if item == n {
			lastIndex = index
		}
	}
	return lastIndex
}

func ReplaceByte(slice []byte, old, new byte) []byte {
	for index, item := range slice {
		if item == old {
			slice[index] = new
			return slice
		}
	}
	return slice
}

func ReplaceBool(slice []bool, old, new bool) []bool {
	for index, item := range slice {
		if item == old {
			slice[index] = new
			return slice
		}
	}
	return slice
}

func ReplaceInt(slice []int, old, new int) []int {
	for index, item := range slice {
		if item == old {
			slice[index] = new
			return slice
		}
	}
	return slice
}

func ReplaceFloat32(slice []float32, old, new float32) []float32 {
	for index, item := range slice {
		if item == old {
			slice[index] = new
			return slice
		}
	}
	return slice
}

func ReplaceFloat64(slice []float64, old, new float64) []float64 {
	for index, item := range slice {
		if item == old {
			slice[index] = new
			return slice
		}
	}
	return slice
}

func ReplaceString(slice []string, old, new string) []string {
	for index, item := range slice {
		if item == old {
			slice[index] = new
			return slice
		}
	}
	return slice
}

func ReplaceInt8(slice []int8, old, new int8) []int8 {
	for index, item := range slice {
		if item == old {
			slice[index] = new
			return slice
		}
	}
	return slice
}

func ReplaceInt16(slice []int16, old, new int16) []int16 {
	for index, item := range slice {
		if item == old {
			slice[index] = new
			return slice
		}
	}
	return slice
}

func ReplaceAllByte(slice []byte, old, new byte) []byte {
	for index, item := range slice {
		if item == old {
			slice[index] = new
		}
	}
	return slice
}

func ReplaceAllBool(slice []bool, old, new bool) []bool {
	for index, item := range slice {
		if item == old {
			slice[index] = new
		}
	}
	return slice
}

func ReplaceAllInt(slice []int, old, new int) []int {
	for index, item := range slice {
		if item == old {
			slice[index] = new
		}
	}
	return slice
}

func ReplaceAllFloat32(slice []float32, old, new float32) []float32 {
	for index, item := range slice {
		if item == old {
			slice[index] = new
		}
	}
	return slice
}

func ReplaceAllFloat64(slice []float64, old, new float64) []float64 {
	for index, item := range slice {
		if item == old {
			slice[index] = new
		}
	}
	return slice
}

func ReplaceAllString(slice []string, old, new string) []string {
	for index, item := range slice {
		if item == old {
			slice[index] = new
		}
	}
	return slice
}

func ReplaceAllInt8(slice []int8, old, new int8) []int8 {
	for index, item := range slice {
		if item == old {
			slice[index] = new
		}
	}
	return slice
}

func ReplaceAllInt16(slice []int16, old, new int16) []int16 {
	for index, item := range slice {
		if item == old {
			slice[index] = new
		}
	}
	return slice
}
